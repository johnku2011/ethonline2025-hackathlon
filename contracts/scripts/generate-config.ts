import { writeFileSync, mkdirSync, existsSync, readFileSync } from 'fs';
import { join } from 'path';

/**
 * Configuration Generator for Frontend
 *
 * This script automates the process of syncing deployed contract addresses
 * and ABIs to the Next.js frontend after each deployment.
 *
 * Design Pattern: Template Method Pattern
 * - Defines the skeleton of the configuration generation algorithm
 * - Allows subclasses (different networks) to override specific steps
 */

interface DeploymentInfo {
  chainId: string;
  contracts: {
    SubscriptionManager: string;
    MockMorphoVault: string;
  };
}

/**
 * Read deployment addresses from Hardhat Ignition deployment folder
 */
function readDeploymentAddresses(network: string): DeploymentInfo | null {
  const deploymentPath = join(__dirname, '..', 'ignition', 'deployments');

  if (!existsSync(deploymentPath)) {
    console.warn('‚ö†Ô∏è  No deployments found. Run deployment first.');
    return null;
  }

  // Find the latest deployment folder for the network
  const deploymentFile = join(
    deploymentPath,
    `chain-${network}`,
    'deployed_addresses.json'
  );

  if (!existsSync(deploymentFile)) {
    console.warn(`‚ö†Ô∏è  No deployment found for network: ${network}`);
    return null;
  }

  const addresses = JSON.parse(readFileSync(deploymentFile, 'utf-8'));

  return {
    chainId: network,
    contracts: {
      SubscriptionManager:
        addresses['SubscriptionManagerModule#SubscriptionManager'] || '',
      MockMorphoVault: addresses['MockMorphoVaultModule#MockMorphoVault'] || '',
    },
  };
}

/**
 * Generate TypeScript configuration file for frontend
 */
function generateAddressesConfig(
  deployment: DeploymentInfo,
  outputDir: string
) {
  const content = `/**
 * Auto-generated contract addresses
 * Generated at: ${new Date().toISOString()}
 * 
 * DO NOT EDIT MANUALLY - This file is auto-generated by scripts/generate-config.ts
 */

export const CONTRACT_ADDRESSES = {
  subscriptionManager: '${deployment.contracts.SubscriptionManager}' as const,
  morphoVault: '${deployment.contracts.MockMorphoVault}' as const,
} as const;

export const CHAIN_ID = '${deployment.chainId}' as const;
`;

  const filePath = join(outputDir, 'addresses.ts');
  writeFileSync(filePath, content);
  console.log(`‚úÖ Generated addresses config: ${filePath}`);
}

/**
 * Copy ABIs from artifacts to frontend
 */
function generateABIsConfig(outputDir: string) {
  const artifactsPath = join(__dirname, '..', 'artifacts', 'contracts');

  const subscriptionManagerABI = JSON.parse(
    readFileSync(
      join(
        artifactsPath,
        'SubscriptionManager.sol',
        'SubscriptionManager.json'
      ),
      'utf-8'
    )
  ).abi;

  const content = `/**
 * Auto-generated contract ABIs
 * Generated at: ${new Date().toISOString()}
 * 
 * DO NOT EDIT MANUALLY - This file is auto-generated by scripts/generate-config.ts
 */

export const SUBSCRIPTION_MANAGER_ABI = ${JSON.stringify(subscriptionManagerABI, null, 2)} as const;
`;

  const filePath = join(outputDir, 'abis.ts');
  writeFileSync(filePath, content);
  console.log(`‚úÖ Generated ABIs config: ${filePath}`);
}

/**
 * Main execution
 */
async function main() {
  const network = process.env.NETWORK || '421614'; // Default: Arbitrum Sepolia
  const outputDir = join(__dirname, '..', '..', 'app', 'lib', 'contracts');

  console.log('üöÄ Generating frontend configuration...');
  console.log(`üì° Network: ${network}`);

  // Create output directory if it doesn't exist
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  // Read deployment info
  const deployment = readDeploymentAddresses(network);
  if (!deployment) {
    process.exit(1);
  }

  // Generate configs
  generateAddressesConfig(deployment, outputDir);
  generateABIsConfig(outputDir);

  console.log('‚ú® Configuration generation complete!');
}

main().catch((error) => {
  console.error('‚ùå Error:', error);
  process.exit(1);
});
